---
layout:     post
title: 	    "Blog: Livet uden XOR"
post_author:	    Poul-Henning Kamp
post_date:	    Fri, 20 Feb 2015 19:35:00 +0000
post_site:	    www.version2.dk 
post_link:	    http://www.version2.dk/blog/livet-uden-xor-82264?utm_medium=feed&utm_source=version2.dk&utm_campaign=it_nyheder
---
<html><body><div><section class="body"><p>Data Generals NOVA CPU var i praksis den første rigtige RISC CPU.</p>

<p>Det betød blandt andet at den ikke havde nogen "OR" instruktion, men som alle der har haft boolsk algebra ved, kan man lave "OR" ud af "AND" og nogle invertere.</p>

<p>Men man kan gøre sådan her:</p>

<div class="geshifilter"><pre class="text geshifilter-text">14. Perform the inclusive OR of the operands in AC0 and
    AC1.  The result is placed in AC1.  The carry bit is
    unchanged.
 
     COM     0,0     // AC0 = ~AC0
     AND     0,1     // AC1 &amp;= AC0
     ADC     0,1     // AC1 += ~AC0</pre></div>

<p>Men det bliver bedre endnu, for der var heller ikke nogen "XOR" instruktion, men derimod:</p>

<div class="geshifilter"><pre class="text geshifilter-text">15. Perform the exclusive OR of the operands in AC0 and
    AC1.  The result is placed in AC1.  The contents of
    AC2 and the carry bit are destroyed.
 
     MOV     1,2     // AC2 = AC1
     ANDZL   0,2     // AC2 = (AC2 &amp; AC0) &lt;&lt; 1
     ADD     0,1     // AC1 += AC0
     SUB     2,1     // AC1 -= AC2</pre></div>

<p>Eksemplerne er fra Regnecentralens manual for "RC3803" videreudviklingen af Nova CPU'en og kan findes omkring side 120 i <a href="http://datamuseum.dk/w/images/3/3d/RCSL_42_I_1008.pdf">RCSL-42-I-1008</a> manualen.</p>

<p>Weekendens datahistoriske hjernevrider er at forklare hvordan de to stykker kode virker og hvorfor XOR ødelægger carry bit, mens OR kan lade den være uændret.</p>

<p><em>phk</em></p>
  </section></div></body></html>
